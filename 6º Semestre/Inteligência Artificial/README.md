##### Rio, 18/08/2017
Apresentação da matéria e Trabalho passado para casa.

***

##### Rio, 25/08/2017

Inteligência artificial consiste em fazer com que os computadores passaem a fazer coisas que os humanos ainda fazem melhor.

Os fundamentos de IA iniciou como uma Filosofia no ano 423 AC, posteriormente passando pro âmbito da Matemática no ano 800 AC, Psicologia em 1879 DC e por fim Linguística em 1957 DC.

No início houve uma grande indecisão pela abordagem lógica baseada em conhecimento, já em 1980 os sistemas especialistas haviam dominado a IA. Estatísticas estava fora de uso de reconecimento de padrões de recuperçaão de informações.

Entre 1969 a 1979 tomaram uma verdadeira dose de realidade e IA descobre a complexidade computacional. 

Entre 1980 e 1988 a IA torna parte da indústria com o retorno das Redes Neurais e a nova IA em 1986 através de um algorítmo de aprendizagem de retro programação foi "reinventado".

**Técnicas utilizadas em IA:**
- Resolução de problemas
- Métodos de busca
- Representação de conhecimento
- Sistemas especialistas (RBL e RBC)
- Agentes
- Aprendizagem de máquinas
- Lógicas de Fuzzy (Técnica onde os valores são feitas em variáveis linguísticas)
- Algoritmos genéricos (Analise como os seres vivos sofrem suas mutações durante a evolução)
- Conexionismo (Trabalha na conexão do sistema nervoso dos seres vivos)
- PLN (Programação de linguagem natural, fazer programa para serem FALADOS)
- Robótica
- Mineração de dados
 

**Agentes:**
> Entidade computacional que funciona de fomra contínua e autônoma em um ambiente restrito. Pode coexistir com outros agentes com características comuns ou não.


**As técnicas de IA são métodos que exploram o conhecimento e devem ser representadas de maneiras:**
- Conhecimento capture a generalização
- Possam ser compreendidas pelas pessoas que forneçam
- Possam ser facilmente modificadas para correção de erros
- Possam ser utilizadas em uma variedade de situações


**Características de Sistemas de IA:**
- Sistemas de IA não fornecem resultados exatos
- Sempre que houver soluções fechadas a IA não é competitiva
- Havendo incerteza, ambiguidade ou preferência humana a IA é imbatível
- IA mexe com o imaginário e permite **cobrar mais caro**


### Aprendizagem de Máquinas

Começou a florescer nos anos 90, focando em métodos e modelos emprestados da estatísticas e da teoria da probabilidade, se beneficiou do crescente número de informações digitalizadas disponível.

Com a aprendizagem de máquinas e a mineração de dados possibilitam fazer uso dos mesmos métodos e se sobrepôem, focando em permitir previsões, descobrir propriedades (previamente) _desconhecidas_ nos dados.
> - Aprendizado -> Prever
> - Mineração -> Descobrir

**Tecnologias em aprendizagens:**
- Árvore de decisão
- Naive Bayes
- Regressão de Logísticas
- Redes Neurais
- Etc

**Análise de Agrupamentos:**
Dada uma coleção de objetos a fim de formar grupo com base familiar, usando a ciência "baseada em descoberta" encontra padrões inesperados em dados, gerando aprendizagem não supervisionada podendo causar um problema _mal definido_.

Por ser mal definido precisa ser interpretado (esta incerteza) com novas variáveis, informações ou atributos de um novo "padrão" possível.

**Redes Naurais:**
Uma rede naural artificial petence em um modelo matemático que tende a "imitar" uma célula de neurônio de seres vivos. Onde a informação é generada através de particulas de carga elétrica e modificam o estado elétrico da célula que já se econtrava no local através de uma descarga elétrica. (Zeros e Uns)



**Deep Learning:**
É a área de IA que vem desde 2006, sendo acelerado após 2010. Tem grande variação das Redes Neurais na questão de profundidade das camadas ocultas. Onde as redes neurais tem poucas camadas ocultas a deep learning trabalha com muitas, tendo mais informações a serem passadas e aprendidas ao passar em cada camada.



***

##### Rio, 01/09/2017

### Big Data Analytics

Os **3V**:

**Volume:** Troca de e-mail, transações bancárias, interações em redes sociais, registro de chamadas e tráfego de dados em linhas telefônicas e principalmente logs.

**Velocidade:** Capacidade de analáse em tempo real.

**Variedade:** Dados estruturado e não estruturado.

Hoje em dia já existe muitas ferramentas de auxilio para criação de ferramentas de mineração em BI.

**Fatos dfe Big data:**
- Menos de 1% de dados do mundo ão analisados.
- Mais dados dforam criados nos último 5 anos
- Em agosto de 2015, mais de  bilhão de pessoas usaram o Facebook em um único dia.
- Em 2017, a expectativa é de 2 bilhoes de usários de acessa ao Facebook.

 
O Termo foi tão usado comercialmente que perdeu o sentido, acaba sendo como sexo na adolescencia onde todos falam sobre, onde na verdade ninguém sabe exatamente como fazer, todos pensam que estão fazendo e por isso afirmam que fazem.


**Conhecimento em:**
- Estatística
- Computação
- Negócio
- Projetos

**Titulação**
- Ph.D
- MSc

**Personalidade:**
- Pensamento orientado a negócias
- Saber fazer as perguntas certas

**Pesquisar:**
- Hadoop (Hive com Rui) [Faz processamento no HD]
- Cloudera
- MapReduce
- AWS EMR (Elastic MapReduce)
- Apache Spark [Faz o processamento na memória]



Hadoop é um softare de código aberto devesenvolvido em Java para computação distribuída, é escalável horizontalmente e tolerante a falhas.

O grande ganho com esta plataforma é a redução de compplexidade para computação distribuída, pois todo o processo ocorre através da integração software e maquina.

Um ambiente de processamento em parelo, se faz necessário especificar praticamente tudo, desde quem é o processadr que envia, para onde envia, como envia. Do lado que recebe, qual o processador que recebe, o que recebe, como recebe, etc.

Hadoop gerencia tudo isto, de forma única. Basta utilizar o paradigma de programação **Map Reduce**, que todo o processamento é distribuído de forma implícita, uma vez que o dado esteja contido no **HDFS**.

A técnica comeceu sendo:
- HDFS era o hardware
- Map Reduce era o software


***

##### Rio, 08/09/2017

### Analytics em Tudo

MeetUp
> Plataforma de prover possibilidade de de agrupar pessoas que tem o mesmo interesse em um determinado assunto.

Dados aberto
> Dados aberto é um dado que pode ser livremente utilizado, reutilizado e redistribuído por qualquer um (Manual dos Dados Abertos: governo)

Características de um dados aberto:
- Disponibilidade de Acesso
- Reuso e redistribuição
- particição universal
- Completos
- Primários
- Atuais
- Acessíveis 
- Compreensíveis por máquinas
- Não proprietário
- Livres de licenças

**Estratégias:**
Disponibilizar um conjunto de dados brutos, com máximo de detalhamento possível, permite que a sociedade use os dados de maneira mais dinâmica, por exemplo, convertendo em outros formatos ou mesmo integrando com outros recursos; sendo disponibilizados por API ou para baixar.



***

##### Rio, 15/09/2017

### Processo de Stemming

Contextualização: Minaração de Texto
> É um algoritimo de mineração de texto, onde através com os dados de entrada, é sofrida uma extração de conhecimento ganhando segmentos contextualizados. 

Contam como algorítimo: 
- Segmentação
- Categorização
- Clustering

Segmentos:
Prefixo + Radical + Sufico
- **Comput**ador 
- **Comput**ação
- **Comput**adorizado




***

##### Rio, 06/10/2017

14/10/2017 - Novo prazo para entrega de trabalhos.
20/10/2017 - Novo prazo para entrega do trabalho A1.





***

##### Rio, 03/11/2017
###### 1ª Aula do Professor Marcelo Teixeira

##
### Busca

Todo **sistema inteligente** tem obrigatoriamente duas caracteristicas que são: **busca** e **representação do conhecimento**.


Tem como algoritimos de busca não informada (cega que não usa IA):
- Algorítmo em Profundidade
- Algorítimo em Amplitude

Busca Informada (ou chamada de busca Heurística):
- Busca pela Melhor Escolha (mais conhecido (Busca Heurística))
- Busca no Espaço de Estado
 

### Representação do Conhecimento

1) Métodos fracos de pela Solução de Problemas (Soluções para abraçar o mundo):
 - Lógica de Predicados
 - Redes Semânticas
 - Frames
 
2) Métodos Fortes para Solução de Problemas (Soluções voltada para situações específicas):
- Sistemas Especialistas (Logica de funcionamento que é chamada de lógica clássica, onde uma dor de cabeça pode ser **com dor** ou **sem dor** de cabeça)
- Sistemas Fuzzy (Já no sistema Fuzzy uma dor de cabeça ganha mais possibilidades onde que pode haver **nenhuma dor**, **pouca dor**, **muita dor**)
- Redes Bayesianas (Sistema voltado a probalidade, onde ele oferece uma porcentagem de uma doença por exemplo)


3) Sistemas Distribuídos
- Redes Neurais Artificiais
- Algoritmos Genéticos


#### Aprendizagem (Mineração de Dados)
Sistemas de computadores onde são extraídos informações úteis através de dados.

Algorítimos de Aprendizagem:
- Conexionista (Utilizado para redes neurais artificiais)
- Evolucionária (Utilizado para algorítimos genéticos - Darwin com a teoria da evolução da espécie)
- Simbólica (Utiliza Árvores de Decisão (ID3))


#### Algoritmo de Busca de Estados
Arquivo EEBEE.ppt na pasta ensina como realizar a busca por algoritmo.

Questão 2 do arquivo simuladoIA2013A1.doc da pasta virtual

**Busca por profundidade**

Sai pela esquerda, e entra pela esquerda. (QUESTÃO DA PROVA)
<table>
    <tr>
        <td><b>Examinado</b></td>
        <td><b>Abertos</b><br>(Não examinados)</td>
        <td><b>Fechado</b><br>(Já examinado)</td>
    </tr>
    <tr>
        <td></td>
        <td>[A]</td>
        <td>[]</td>
    </tr>
    <tr>
        <td>A</td>
        <td>[B,C]</td>
        <td>[A]</td>
    </tr>
    <tr>
        <td>B</td>
        <td>[F,E,C]</td>
        <td>[B,A]</td>
    </tr>
    <tr>
        <td>F</td>
        <td>[K,E,C]</td>
        <td>[F,B,A]</td>
    </tr>
    <tr>
        <td>K</td>
        <td>[E,C]</td>
        <td>[K,F,B,A]</td>
    </tr>
    <tr>
        <td>E</td>
        <td>[C]</td>
        <td>[E,K,F,B,A]</td>
    </tr>
    <tr>
        <td>C</td>
        <td>[<b>E</b>,D,G] (descarta filhos fechados ou em abertos no caso o <b>E</b>)</td>
        <td>[C,E,K,F,B,A]</td>
    </tr>
    <tr>
        <td>D</td>
        <td></td>
        <td></td>
    </tr>
</table>

##

**Busca por amplitude (ou largura)**

Sai pela esquerda e entra pela direita. (QUESTÃO DA PROVA)
<table>
    <tr>
        <td><b>Examinado</b></td>
        <td><b>Abertos</b><br>(Não examinados)</td>
        <td><b>Fechado</b><br>(Já examinado)</td>
    </tr>
    <tr>
        <td></td>
        <td>[A]</td>
        <td>[]</td>
    </tr>
    <tr>
        <td>A</td>
        <td>[B,C]</td>
        <td>[A]</td>
    </tr>
    <tr>
        <td>B</td>
        <td>[C,F,E]</td>
        <td>[B,A]</td>
    </tr>
    <tr>
        <td>C</td>
        <td>[F,E,D,G] (<b>E</b> não entra novamente pois já se econtra na lista)</td>
        <td>[C,B,A]</td>
    </tr>
    <tr>
        <td>F</td>
        <td>[E,D,G,K]</td>
        <td>[F,C,B,A]</td>
    </tr>
    <tr>
        <td>E</td>
        <td>[D,G,K]</td>
        <td>[E,F,C,B,A]</td>
    </tr>
    <tr>
        <td>D</td>
        <td>[G,K]</td>
        <td>[D,E,F,C,B,A]</td>
    </tr>
    <tr>
        <td>G</td>
        <td>[K,L,M]</td>
        <td>[G,D,E,F,C,B,A]</td>
    </tr>
    <tr>
        <td>K</td>
        <td></td>
        <td></td>
    </tr>
</table>



#### Algoritmo de Heurística
Arquivo EEBEE.ppt na pasta ensina como realizar a busca por algoritmo.

Essa técnica tende a criar uma fórmula onde a heurística chegue mais próximo a percepção humana.
A coluna n será dada na prova junto com a coluna h(n), teremos que preencher a coluna g(n) (que é o nivel da árvore, onde a raiz eh o nível zero) e a coluna f(n) que é a soma de g(n) + h(n). ( f(n) = g(n) + h(n) )



**Busca pela melhor escolha (Heurística)**

Sai pela esquerda e entra seguindo a ordem do menor valor, valores iguals entram a direita. (QUESTÃO DA PROVA)
<table>
    <tr>
        <td><b>Examinado</b></td>
        <td><b>Abertos</b><br>(Não examinados)</td>
        <td><b>Fechado</b><br>(Já examinado)</td>
    </tr>
    <tr>
        <td></td>
        <td>[A4] Onde 4 é o valor de f(n)</td>
        <td>[]</td>
    </tr>
    <tr>
        <td>A4</td>
        <td>[B6,C6]</td>
        <td>[A4]</td>
    </tr>
    <tr>
        <td>B6</td>
        <td>[F5,C6,E7]</td>
        <td>[B6,A4]</td>
    </tr>
    <tr>
        <td>F5</td>
        <td>[C6,E7,K7]</td>
        <td>[F5,B6,A4]</td>
    </tr>
    <tr>
        <td>C6</td>
        <td>[D4,E7,K7,G7]</td>
        <td>[C6,F5,B6,A4]</td>
    </tr>
    <tr>
        <td>D4</td>
        <td>[E7,K7,G7]</td>
        <td>[D4,C6,F5,B6,A4]</td>
    </tr>
    <tr>
        <td>E7</td>
        <td>[K7,G7]</td>
        <td>[E7,D4,C6,F5,B6,A4]</td>
    </tr>
    <tr>
        <td>K7</td>
        <td>[G7]</td>
        <td>[K7,E7,D4,C6,F5,B6,A4]</td>
    </tr>
    <tr>
        <td>G7</td>
        <td>[L7,M9]</td>
        <td>[G7,K7,E7,D4,C6,F5,B6,A4]</td>
    </tr>
    <tr>
        <td>L7</td>
        <td></td>
        <td></td>
    </tr>
</table>    





***

##### Rio, 10/11/2017
###### 2ª Aula do Professor Marcelo Teixeira

### Sistemas Especialistas 

Programa de sistema especialista é um programa onde é baseado em conhecimento humano especialista. O programa tem foco de lhe perguntar e em cima das respostas do usário ele entrega uma posição especializada em cima das respostas do usuário.

Na expressão "se condição então conclusão" o sistema progressivo  usa a a condição para chegar na conclusão, já em sistemas regressivos é utilizado a conclusão pra chegar na condição.


#### Pilha de Regras de sistemas regressivos
Arquivo simuladoIA2013A1.doc - Começando com regra vazia:

<table>
    <tr>
        <td>
            []<br>
            [ se <b>prob2</b> ou <b>prob3</b> então resfriado ]<br>
            <i>Ler as regras que tem conclusão de prob2 e colocar no topo:</i><br>
            [ 
                se <span style="color: #f00"><b>vômito</b></span> ou <span style="color: #f00"><b>tosse</b></span> então prob2, <br>
                se <b>prob2</b> ou <b>prob3</b> então resfriado
            ]<br><br>
            <i>Como <b>vômito</b> e <b>tosse</b> foram respondidas pelo usuário como não, elas são consideradas falsas fazendo que prob2 seja falso. Retirando a expressão do lista.</i><br>
            [ se <span style="color: #f00"><b>prob2</b></span> ou <b>prob3</b> então resfriado ]<br><br>
            Ler agora as regras  que tem conclusão de prob3 e colocar no topo:</b><br>
            [ 
                se <b>coriza</b> ou <b>dor</b> então prob3, <br>
                se <span style="color: #f00"><b>prob2</b></span> ou <b>prob3</b> então resfriado
            ]<br><br>
            Usuário perguntou o <b>porque</b> em coriza, o que gera a mensagem de explicação:<br><br>
            Porque<br>
            posso usar <b>coriza</b> para investigar <b>prob3</b> pela regra <b>se coriza e dor então prob3</b>, e posso usar <b>prob3</b> para investigar <b>resfriado</b> pela regra <b>se prob2 ou prob3 então resfriado</b>, e <b>resfriado</b> foi sua pergunta original.
        </td>
    </tr>
</table>    


Na pasta SistemasEspecialistasEmProlog fazer os exercícios 'Exercícios-SE-porque' e ver o 'se-regressivo-porque' pois foi utilizado em sala de aula, questão 6 do arquivo 'simuladoIA2013A1.doc'.



### Aprendizado de Máquina: Simbólico
##### Aprendizagem de Árvores de Decisão (programa ID3)
A forma de ensinar/treinar a máquina, damos um conjunto de casos/exemplos para treinamento.



***

##### Rio, 17/11/2017
###### 3ª Aula do Professor Marcelo Teixeira

### Redes Neurais

#### Redes de Multi Camadas
Arquivo RC.ppt. Pegar matéria.

#### Treinamento do Perceptron 
(QUESTÃO DA PROVA)<br>
Arquivo **ExercicioPerceptron.ppt** serve como base e explicação.

real = f(net) onde net é igual a soma das multiplicações de todos os **x** pelos **w**, exemplo de um vetor de 3 posições (x1\*w1 + x2\*w2 + x3\*w3). Se f(net) for maior que zero o resultado é 1, se for menor que zero o resulturado é -1.

Δw = C * (desejado - real) * x<br>
C = Taxa de aprendizagem<br>
x = é o x 

Realizar todas as contas para cada linha da tabela, usando sempre o último **Wx** calculado.


Fazer a questão 4 do arquivo **SimuladoIA2013A2.doc**.


### Algorítimos Genéticos
Questão 2 do arquivo **SimuladoIA2013A2.doc**.<br>
Joga na f:<br>
a) Aptidão:<br>
f(x1) = [1][0][0][0][0][1] = [a][b][c][d][e][f] = 4<br>
f(x2) = [0][1][0][0][1][1] = [a][b][c][d][e][f] = 3<br>
f(x3) = [0][1][0][0][1][0] = [a][b][c][d][e][f] = 2<br>
f(x4) = [1][1][0][0][1][0] = [a][b][c][d][e][f] = 1<br>

b) Soma todos os resultados da aptidão para usar abaixo, no caso a soma é (4+3+2+1) = 10.<br>
fr(x1) = 4/10 = 0.4<br>
fr(x2) = 3/10 = 0.3<br>
fr(x3) = 2/10 = 0.2<br>
fr(x4) = 1/10 = 0.1<br>

c) c1 sempre será ZERO<br>
se 0.0 <= aleatório < 0.4 então x1<br>
se 0.4 <= aleatório < 0.7 então x2<br>
se 0.7 <= aleatório < 0.9 então x3<br>
se 0.9 <= aleatório < 1.0 então x4

d) Pais:<br>
Aleaório 0.98 => x4 [1][1][0][0][1][0]<br>
Aleaório 0.26 => x1 [1][0][0][0][0][1]<br>

Pega o 'crossover' e quebra no meio como dado na questão, pegando início do primeiro X e final do segundo X<br>
Filhos:<br>
x4' [1][1][0] [0][0][1]<br>
x1' [1][0][0] [0][1][0]<br>



### Programação Genética (Linguagem Lisp)





***

##### Rio, 24/11/2017
###### 4ª Aula do Professor Marcelo Teixeira

Uma questão da prova será em Lisp com recursividade.
```LISP
(
	DEFUN POSITIVO (NUM)(
		COND
			((> NUM 0) T)
			(T NIL) 
	)
)
```

```LISP
(
	DEFUN fatorial (n) (
		COND 
			( (<= N 0 ) 1 )
			( T ( * n (fatorial (- n 1)) ) )
		
	)
)
```

```LISP
(
	DEFUN soma (a b) (
		COND
			((= a b) a)
			((< a b) (+ a (soma (+ a 1) b)))
			(T (soma b a))
	)
)
```

```LISP
(
	DEFUN logdois (x) (
		COND
			((<= x 1.0) 0)
			((AND (< 1.0 x) (>= x 2)) 1)
			(T (+ 1 (logdois (/ x 2))))
	)
)
```

```LISP
(
	DEFUN genma(n)(
		COND
			((< N 4) (- n))
			((= N 4) (- (genma (- 4 n))))
			(T (+ n (* 11 (genma (- N 2)))))
	)
)
```

#### Representação do Conhecimento
- Métodos Fracos: Lógicas de Predicados, Redes Semânticas, Frames.
- Métodos Fortes: Sistemas Especialistas, Redes Bayesianas, Sistemas Fuzzy.
- Distribuídas: Redes Neurais Artificiais, Algoritmos Genéticos.

#### Teorema de Bayes
Probabilidade => p(a | B) = p(a ^ b) / p(b)


***


#### Revisão da Prova

Arquivo 'SimuladoIA2013A1.doc' CAI as questões 1,2,3 e 6.
<br>
1ª Questão) Diretórios 'Apostilas em Prolog' no arquivo introdução, ver o 2º capítulo onde fala de Progenitor que irá cair na prova.  ver no Arquivo IA.ppt
<br>
2ª Quetão) Busca em profundidade ou Amplitude que se encontra no arquivo EEBEE.ppt
<br>
3ª Questão) Busca pela melhor escolha que se encontra no arquivo EEBEE.ppt
<br>
4ª Questão) Sistemas Especialistas: Parecida com a questão 6 do arquivo SimuladoIA2013A1.doc e na pasta SistemasEspecialistasEmProlog no arquivo Exercicios-SE-porque.
<br>

Arquivo 'SimuladoIA2013A2.doc' NÃO CAI a quesão 2,3,6.
<br>
5ª Questão) Questão número 2 do arquivo SimuladoIA2013A2.doc, Algoritmos genéticos de SAT FNC
<br>
6ª Questão) Questão 4 do arquivo SimuladoIA2013A2.doc se guiar pelo exemplo do arquivo ExercicioPerceptron.ppt
<br>
7ª Questão) Questão 5 do arquivo simuladoIA2013A2.doc cai.








